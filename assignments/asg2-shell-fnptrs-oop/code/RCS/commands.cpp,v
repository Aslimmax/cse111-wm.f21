head	1.31;
access;
symbols;
locks;
comment	@// @;


1.31
date	2021.10.30.08.14.20;	author -;	state -;
branches;
next	1.30;

1.30
date	2021.10.30.06.28.45;	author -;	state -;
branches;
next	1.29;

1.29
date	2021.10.30.00.35.41;	author -;	state -;
branches;
next	1.28;

1.28
date	2021.10.29.23.51.43;	author -;	state -;
branches;
next	1.27;

1.27
date	2021.10.29.20.30.54;	author -;	state -;
branches;
next	1.26;

1.26
date	2021.10.29.19.45.52;	author -;	state -;
branches;
next	1.25;

1.25
date	2021.10.28.02.15.14;	author -;	state -;
branches;
next	1.24;

1.24
date	2021.10.28.00.42.59;	author -;	state -;
branches;
next	1.23;

1.23
date	2021.10.27.22.19.03;	author -;	state -;
branches;
next	1.22;

1.22
date	2021.10.26.21.51.44;	author -;	state -;
branches;
next	1.21;

1.21
date	2021.09.26.19.41.17;	author -;	state -;
branches;
next	1.20;

1.20
date	2021.01.11.23.52.17;	author -;	state -;
branches;
next	1.19;

1.19
date	2020.10.21.01.23.13;	author -;	state -;
branches;
next	1.18;

1.18
date	2019.10.08.20.55.31;	author -;	state -;
branches;
next	1.17;

1.17
date	2018.01.25.22.02.55;	author -;	state -;
branches;
next	1.16;

1.16
date	2016.01.15.00.10.40;	author -;	state -;
branches;
next	1.15;

1.15
date	2016.01.14.23.13.33;	author -;	state -;
branches;
next	1.14;

1.14
date	2016.01.14.22.45.21;	author -;	state -;
branches;
next	1.13;

1.13
date	2016.01.14.00.21.53;	author -;	state -;
branches;
next	1.12;

1.12
date	2016.01.13.21.49.20;	author -;	state -;
branches;
next	1.11;

1.11
date	2014.06.11.20.49.31;	author -;	state -;
branches;
next	1.10;

1.10
date	2014.04.10.00.04.58;	author -;	state -;
branches;
next	1.9;

1.9
date	2014.03.27.02.55.18;	author -;	state -;
branches;
next	1.8;

1.8
date	2014.03.27.01.39.40;	author -;	state -;
branches;
next	1.7;

1.7
date	2014.03.27.00.15.54;	author -;	state -;
branches;
next	1.6;

1.6
date	2013.06.19.01.26.51;	author -;	state -;
branches;
next	1.5;

1.5
date	2013.06.19.01.02.12;	author -;	state -;
branches;
next	1.4;

1.4
date	2013.06.19.01.00.53;	author -;	state -;
branches;
next	1.3;

1.3
date	2013.06.19.01.00.24;	author -;	state -;
branches;
next	1.2;

1.2
date	2013.06.19.00.59.10;	author -;	state -;
branches;
next	1.1;

1.1
date	2013.06.19.00.31.28;	author -;	state -;
branches;
next	;


desc
@@


1.31
log
@-
@
text
@// $Id: commands.cpp,v 1.30 2021-10-29 23:28:45-07 - - $

#include "commands.h"
#include "debug.h"

command_hash cmd_hash {
   {"cat"   , fn_cat   },
   {"cd"    , fn_cd    },
   {"echo"  , fn_echo  },
   {"exit"  , fn_exit  },
   {"ls"    , fn_ls    },
   {"lsr"   , fn_lsr   },
   {"make"  , fn_make  },
   {"mkdir" , fn_mkdir },
   {"prompt", fn_prompt},
   {"pwd"   , fn_pwd   },
   {"rm"    , fn_rm    },
   {"rmr"   , fn_rmr   },
};

/*
 * Return the command in cmd_hash unordered map based on command passed
 * 
 * Input: constant string reference cmd
 * Output: command_fn to which function needs to be executed. If the
 * command doesn't exist, throw a command_error
 */
command_fn find_command_fn (const string& cmd) {
   // Note: value_type is pair<const key_type, mapped_type>
   // So: iterator->first is key_type (string)
   // So: iterator->second is mapped_type (command_fn)
   DEBUGF ('c', "[" << cmd << "]");
   const auto result {cmd_hash.find (cmd)};
   if (result == cmd_hash.end()) {
      throw command_error (cmd + ": no such command");
   }
   return result->second;
}

command_error::command_error (const string& what):
            runtime_error (what) {
}

int exit_status_message() {
   int status {exec::status()};
   cout << exec::execname() << ": exit(" << status << ")" << endl;
   return status;
}

/**
 * Copy the contents of each file to the standard output
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_cat (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check that a pathname is specified
   if (words.size() < 1) {
      throw command_error(words.at(0) + ": no file specified");
   }

   // Initialize pointer to the cwd's directory
   inode_ptr directoryPath = state.getCwd();

   // Split the pathname into a wordvec
   wordvec tempPath = split(words.at(1), "/");
      
   // Get the lastpath name
   wordvec lastPath;
   lastPath.push_back(tempPath.back());

   // Check to see if the pathname is longer than one
   if (tempPath.size() != 1) {
      // Get the directory path minus the last pathname
      tempPath = wordvec(tempPath.begin(), tempPath.end() - 1);

      // Determine if subpath is valid
      directoryPath = validPath(state, tempPath);
   }

   // Determine the file type of the last path
   directoryPath = determineFileType(directoryPath, lastPath);

   // If the lastpath points to an element, determine if it's a file
   // or directory
   if (directoryPath->getFileType() == file_type::DIRECTORY_TYPE) {
      throw command_error(words.at(1) + ": Is a directory");
   }

   // Otherwise, element found is a plain_file class
   string outputString = ""; // initialize output string of data
   // Get the fileData
   wordvec fileData = dynamic_pointer_cast<plain_file>
      (directoryPath->getContents())->getData();
   // Loop through plain_file data
   for (wordvec::const_iterator wordIter = fileData.begin(); 
      wordIter != fileData.end(); ++wordIter) {
      outputString += (*wordIter) + " "; // build output string
   }
   // Remove the extra white space at the end of the string
   outputString.pop_back();

   cout << outputString << endl;
}

/**
 * Set the current directory to the pathname given. If no pathname is
 * specified, the root direcotry (/) is used
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_cd (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check that a directory is specified (if not, use the root
   // directory)
   if (words.size() == 1) {
      state.setCwd(state.getRoot());
      // Reset the filepath
      state.resetFilePath();
      return;
   } 

   // Check if more than one operand is given
   if (words.size() > 2) {
      throw command_error(words.at(0) + ": too many operands given");
   }

   // Process the path
   wordvec path = split(words.at(1), "/");

   // Get the ptr to the directory specified
   inode_ptr finalCwdPtr = validPath(state, path);

   // At this point, we have found the directory and confirmed that it 
   // is a directory. Can now update the cwd and filepath

   // Check if there are multiple paths specified
   if (path.size() == 1) {
      // Exit function is trying to cd into itself
      if (path.at(0) == ".") {
         return;
      } // Pop back last element in filepath if going to parent dir
      else if (path.at(0) == "..") {
         // Don't do anything if cwd == root
         if (state.getCwd() != state.getRoot()) {
            state.popFilepath();
         }
      } else { // Otherwise, udpate the filepath
         state.pushFilepath(path.at(0));
      }
   } else {
      // Loop through path and push back to filepath to cwd
      for (wordvec::iterator pathIter = path.begin();
         pathIter != path.end(); ++pathIter) {
         state.pushFilepath((*pathIter));
      }
   }

   // Update cwd
   state.setCwd(finalCwdPtr);
}

/* Echos words, which may be empty, to the standard output on a line
by itself
Input: inode_state obj, wordvec string vector
Output: None
 */
void fn_echo (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);
   cout << word_range (words.cbegin() + 1, words.cend()) << endl;
}

/**
 * Exit the shell (STILL NEED TO CONFIGURE)
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_exit (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);
   throw ysh_exit();
}

/**
 * Print out a description of the files or directories to the standard
 * output. If no pathname is specified, the current working directory is
 * used.
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_ls (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // If no arguments are passed with the command, then dot is used as
   // its operand
   // Print out the pathname specified
   cout << state.getFilepath() + ":" << endl;

   // Initialize pointer to the cwd's directory
   inode_ptr directoryPath = state.getCwd();

   // Check if a pathname was specified
   if (words.size() > 1) {
      directoryPath = validPath(state, words);
   }

   // Set a temporary var to class member dirents
   map<string, inode_ptr> tempDirents = 
      directoryPath->getContents()->getDirents();
   // Loop through dirents
   for (map<string, inode_ptr>::iterator iter = tempDirents.begin();
        iter != tempDirents.end(); ++iter)
   {
      // Stores whether or not the element is a file or directory
      bool isDirectory = true;
      size_t inodeNum = iter->second->get_inode_nr();
      string filePath = iter->first;
      int fileSize = 0;
      inode_ptr inodePtr = iter->second;
            
      // Determine file type
      isDirectory = (inodePtr->getFileType() == 
         file_type::DIRECTORY_TYPE) ? true : false; 
      
      if (isDirectory) {
         fileSize = inodePtr->getContents()->getDirents().size();
         filePath += "/";
      } 
      else { // Otherwise, the file is a PLAIN_TYPE
         fileSize = dynamic_pointer_cast<plain_file>
            (inodePtr->getContents())->size();
      }

      // Print out the completed line
      cout << setw(6) << inodeNum << setw(6) << fileSize << "  "
         << filePath << endl;
   }
}

void fn_lsr (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);
}

/**
 * The file specified is created and the rest of the words are put into
 * that file. If the file already exists, replace its contents.
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_make (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check to see if no arguments were provided
   if (words.size() <= 1) {
      throw command_error(words[0] + ": missing file name");
   }

   // Make and insert an empty file into dirents
   inode_ptr filePtr = state.getCwd()->getContents()->mkfile(words[1]);

   // Check if words were passed to the argument
   // words[0] = command name
   // words[1] = file name
   if (words.size() > 2) {
      // Copy the words into fileContents
      wordvec fileContents = wordvec(words.begin() + 2, words.end());
      // Write to the file
      dynamic_pointer_cast<plain_file>
         (filePtr->getContents())->writefile(fileContents);
   }
}

/**
 * Create a new directory. Two entries are automatically added to this
 * directory, namely dot (.) and dotdot (..).
 * Input: inode_state obj, wordvec, string vector
 * Output: none
 */
void fn_mkdir (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check to see if no arguments were provided
   if (words.size() < 2) {
      throw command_error(words[0] + ": missing directory name");
   }
   
   // Ensure that a duplicate folder will not be added
   if (state.getCwd()->getContents()->mkdir(words[1]) == nullptr) {
      throw command_error(words[1] + ": directory already exists");
   }
}

/**
 * Update the current terminal prompt
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_prompt (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check if no arguemnts were provided
   if (words.size() <= 1) {
      throw command_error(words[0] + ": missing prompt argument");
   }

   string newPromptOutput = ""; // initialize final output
   // Get the new prompt provided by the user
   wordvec newPrompt = wordvec(words.begin() + 1, words.end());

   // Loop through all words in newPrompt
   for (wordvec::iterator iter = newPrompt.begin(); 
      iter != newPrompt.end(); ++iter) {
      // Append each word to the final output
      newPromptOutput += (*iter) + " "; 
   }

   // Change the prompt
   state.setPrompt(newPromptOutput);
}

/**
 * Prints the current working directory
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_pwd (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);   
   // initialize output string for the final path
   string outputPath = ""; 

   outputPath = state.getFilepath();
   
   cout << outputPath << endl;
}

/**
 * Delete the specified file or directory (removed from its parent's
 * list of files and subdirectories). If the pathname is a directory,
 * it must be empty.
 * Input: inode_state obj, wordvec string vector
 * Output: none
 */
void fn_rm (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);

   // Check if no arguemnts were provided
   if (words.size() < 2) {
      throw command_error(words[0] + ": missing operand");
   }

   // Initialize pointer to the cwd's directory
   inode_ptr directoryPath = state.getCwd();

   // wordvec lastPath = words.end());
   wordvec lastPath;
   lastPath.push_back(words.back());
   
   // Check if a pathname was specified
   if (words.size() > 2) {
      // Get the directory path minus the last pathname
      wordvec tempDir = wordvec(words.begin(), words.end() - 1);

      // Determine if the subpath is valid
      directoryPath = validPath(state, tempDir);
   }
   
   // Check to see if the file/directory exists
   map<string, inode_ptr> tempDirents = 
      directoryPath->getContents()->getDirents();
   map<string, inode_ptr>::iterator iter =
      tempDirents.find(lastPath.at(0));
   if (iter == tempDirents.end()) {
      throw command_error(words.at(1) + ": No such file or directory");
   }

   // Check if the file/directory is a directory
   bool isDirectory = (iter->second->getFileType() ==
      file_type::DIRECTORY_TYPE) ? true : false;

   // Check if it's a directory and if it's "empty"
   if (isDirectory) {
      // Get the size of the directory
      size_t directorySize = dynamic_pointer_cast<directory>
         (iter->second->getContents())->getDirents().size();
      if (directorySize != 2) {
         throw command_error(words.at(1) + ": directory is not empty");
      }
   }

   // Remove the file/directory
   directoryPath->getContents()->remove(lastPath.at(0));
}

void fn_rmr (inode_state& state, const wordvec& words) {
   DEBUGF ('c', state);
   DEBUGF ('c', words);
}

/**
 * Check to see if the pathname given leads to a valid directory
 * Input: inode_state obj, wordvec string vector
 * Output: inode_ptr to the specified directory
 */
inode_ptr validPath(inode_state& state, const wordvec& words) {
   // Initialize pointer to the cwd
   inode_ptr finalCwdPtr = state.getCwd();

   // Loop through each path, throw an error if a path doesn't exist
   for (wordvec::const_iterator wordIter = words.begin();
        wordIter != words.end(); ++wordIter)
   {
      // Get the dirents of the cwd
      map<string, inode_ptr> tempDirents =
          finalCwdPtr->getContents()->getDirents();

      // Look for the element based on the given path
      map<string, inode_ptr>::iterator dirIter =
          tempDirents.find((*wordIter));

      if (dirIter == tempDirents.end())
      { // file wasn't found
         throw command_error(words.at(0) +
                             ": directory does not exist");
      }

      // If the directory was found, check that it is not a file
      inode_ptr dirPtr = dirIter->second;
      bool isFile = (dirPtr->getFileType() == file_type::PLAIN_TYPE)
         ? true : false;
      
      // Throw an error if dirPtr is a file
      if (isFile) { 
         throw command_error(words.at(0) + ": Not a directory");
      }

      // Update finalCwdPtr and continue to loop through path
      finalCwdPtr = dirPtr;
   }

   return finalCwdPtr;
}

/**
 * Determines the file type
 * Input: indoe_ptr to a directory, wordvec with a pathname
 * Output: inode_ptr to the file/directory
 */
inode_ptr determineFileType(inode_ptr& inodePtr, 
   const wordvec &words) {
   // Initialize return tuple with the inode_ptr to the file/directory
   // and the filetype of the tuple
   // tuple<inode_ptr, file_type> returnTuple;

   // Look for the specified element in dirents with the specified
   // inodePtr
   map<string, inode_ptr> tempDirents = inodePtr->getContents()
      ->getDirents();
   map<string, inode_ptr>::iterator iter =
      tempDirents.find(words.at(0));

   if (iter == tempDirents.end()) { // file wasn't found
      throw command_error(words.at(0) + ": No such file or directory");
   }

   // If the element is found, update the returnTuple
   // get<0>(returnTuple) = iter->second;
   // get<1>(returnTuple) = iter->second->getFileType();

   // Return the ptr to the element
   return iter->second;
}
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.29 2021-10-29 17:35:41-07 - - $
d59 1
a59 1
   // Check that a file is specified
d64 14
a77 5
   // Look for the specified file in dirents
   map<string, inode_ptr> tempDirents = 
      state.getCwd()->getContents()->getDirents();
   map<string, inode_ptr>::iterator iter =
      tempDirents.find(words.at(1));
d79 2
a80 2
   if (iter == tempDirents.end()) { // file wasn't found
      throw command_error(words.at(1) + ": file does not exist");
d83 2
a84 4
   // If the file was found, check that it is not a directory
   inode_ptr inodePtr = iter->second;
   bool isDirectory = (inodePtr->getFileType() ==
      file_type::DIRECTORY_TYPE) ? true : false;
d86 4
a89 2
   if (isDirectory) {
      throw command_error(words.at(1) + ": this is a directory");
d92 1
a92 1
   // File found is a plain_file class
d96 1
a96 1
      (inodePtr->getContents())->getData();
d135 2
a136 2
   // Get the ptr to the directory specified 
   inode_ptr finalCwdPtr = validPath(state, words);
d281 6
a416 2
   // Process the path
   wordvec path = split(words.at(1), "/");
d421 2
a422 2
   for (wordvec::iterator wordIter = path.begin();
        wordIter != path.end(); ++wordIter)
d434 1
a434 1
         throw command_error(words.at(1) +
d445 1
a445 1
         throw command_error(words.at(1) + ": Not a directory");
d457 27
a483 26
 * Input: indoe_ptr to a directory, wordvec with a pathname, 
 * isDirectory reference
 * Output: inode_ptr to the file/directory, whether the inode_ptr points
 * to a file/directory (isDirectory is modified)
 */
// inode_ptr determineFileType(inode_ptr& inodePtr, 
// const wordvec &words,
//    bool &isDirectory) {
//    // Look for the specified element in dirents
//    map<string, inode_ptr> tempDirents = inodePtr->getContents()
//       ->getDirents();
//    map<string, inode_ptr>::iterator iter =
//       tempDirents.find(words.at(0));

//    if (iter == tempDirents.end()) { // file wasn't found
//       throw command_error(words.at(1) + ": file does not exist");
//    }

//    // If the element is found, determine the filetype
//    inode_ptr inodePtr = iter->second;
//    isDirectory = (inodePtr->getFileType() == 
//       file_type::DIRECTORY_TYPE) ? true: false;

//    // Return the ptr to the element
//    return inodePtr;
// }
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.28 2021-10-29 16:51:43-07 - - $
d20 1
d50 4
a53 4
/* Copy the contents of each file to the standard output
Input: wordvec words
Output: None, but the contents of words is printed to the standard
output
d85 1
d99 6
d109 3
a111 3
   // Check that a directory is specified 
   // (if not, use the root directory)
   if (words.size() < 1) {
d114 3
a116 2
      // throw command_error(words.at(0) + ": no directory specified");
   }
d123 2
a124 5
   // Check that the directory exists
   map<string, inode_ptr> tempDirents =
       state.getCwd()->getContents()->getDirents();
   map<string, inode_ptr>::iterator iter =
       tempDirents.find(words.at(1));
d126 2
a127 3
   if (iter == tempDirents.end()) { // file wasn't found
      throw command_error(words.at(1) + ": directory does not exist");
   }
d129 2
a130 4
   // If the directory was found, check that it is not a file
   inode_ptr inodePtr = iter->second;
   bool isFile = (inodePtr->getFileType() ==
      file_type::PLAIN_TYPE) ? true : false;
d132 20
a151 2
   if (isFile) {
      throw command_error(words.at(1) + ": Not a directory");
d154 2
a155 2
   // At this point, we have found the directory and confirmed that it 
   // is a directory. Can now update the cwd
d160 1
a160 1
Input: inode_state& obj, wordvec& string vector
a167 1

d169 5
d180 7
d193 1
d196 8
d205 2
a206 2
   map<string, inode_ptr> tempDirEnts = 
      state.getCwd()->getContents()->getDirents();
d208 2
a209 2
   for (map<string, inode_ptr>::iterator iter = tempDirEnts.begin();
        iter != tempDirEnts.end(); ++iter)
d242 6
d275 5
d287 5
d316 4
a319 3
/* Prints the current working directory
Input: inode_state obj, words ([0] => name of command, [1] => arguments)
Output: void function
d332 7
d344 1
a344 1
   if (words.size() <= 1) {
d348 41
a388 1
   state.getCwd()->getContents()->remove(words[1]);
d396 74
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.27 2021-10-29 13:30:54-07 - - $
d100 35
d161 1
a161 5
   if (words.size() < 1) {
      cout << "/:" << endl;
   } else {
      cout << "/:" << endl;
   }
d256 1
a256 1
   state.prompt(newPromptOutput);
a267 5
   // If cwd points to root, then we are at the root directory
   if (state.getRoot()->get_inode_nr() == 1) {
      outputPath += "/";
   }
   else {
d269 1
a269 1
   }
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.26 2021-10-29 12:45:52-07 - - $
d251 5
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.25 2021-10-27 19:15:14-07 - - $
d208 18
a225 1
   
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.24 2021-10-27 17:42:59-07 - - $
d49 5
d57 38
d155 2
a156 9
         fileSize = inodePtr->getContents()->getData().size();
         // Store a reference to the wordvec data in plain_file
         // wordvec fileData = inodePtr->getContents()->getData();
         // // Loop through fileData and increment file size
         // for (wordvec::iterator wordIter = fileData.begin();
         //      wordIter != fileData.end(); ++wordIter) {
         //    fileSize += 1;
         // }
         // size = inodePtr->getContents()->getData().size();
d173 19
a191 1
   state.getCwd()->getContents()->mkfile(words[1]);
d207 2
a228 1

@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.23 2021-10-27 15:19:03-07 - - $
d89 3
d93 6
a98 7
   map<string, inode_ptr> dirents = 
      state.getCwd()->getContents()->getDirents();
   for (map<string, inode_ptr>::iterator iter = dirents.begin(); 
      iter != dirents.end(); ++iter) {
      cout << setw(6) << iter->second->get_inode_nr()
         << setw(6) << iter->second->getContents()->getDirents().size();

d100 21
a120 4
      if (filePath == "..") {
         cout << setw(7);
      } else {
         cout << setw(6);
d123 3
a125 2
      // Print out the file path
      cout << filePath << endl;
d137 1
@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.22 2021-10-26 14:51:44-07 - - $
d91 1
a91 1
      state.getCwd()->contents()->getDirents();
d95 1
a95 1
         << setw(6) << dirents.size();
d122 5
d158 2
@


1.22
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.21 2021-09-26 12:41:17-07 - - $
d61 1
a61 1
Input: inode_state& state, wordvec& words (DEBUG: DEFINE EXTENSIVELY)
d80 27
d129 4
d135 13
a147 1
   DEBUGF ('c', words);
@


1.21
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.20 2021-01-11 15:52:17-08 - - $
d20 7
a26 1

d59 5
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.19 2020-10-20 18:23:13-07 - - $
d26 1
a26 1
   const auto result = cmd_hash.find (cmd);
d28 1
a28 1
      throw command_error (cmd + ": no such function");
d38 1
a38 1
   int status = exec::status();
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.18 2019-10-08 13:55:31-07 - - $
d43 1
a43 1
void fn_cat (inode_state& state, const wordvec& words){
d48 1
a48 1
void fn_cd (inode_state& state, const wordvec& words){
d53 1
a53 1
void fn_echo (inode_state& state, const wordvec& words){
d60 1
a60 1
void fn_exit (inode_state& state, const wordvec& words){
d66 1
a66 1
void fn_ls (inode_state& state, const wordvec& words){
d71 1
a71 1
void fn_lsr (inode_state& state, const wordvec& words){
d76 1
a76 1
void fn_make (inode_state& state, const wordvec& words){
d81 1
a81 1
void fn_mkdir (inode_state& state, const wordvec& words){
d86 1
a86 1
void fn_prompt (inode_state& state, const wordvec& words){
d91 1
a91 1
void fn_pwd (inode_state& state, const wordvec& words){
d96 1
a96 1
void fn_rm (inode_state& state, const wordvec& words){
d101 1
a101 1
void fn_rmr (inode_state& state, const wordvec& words){
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.17 2018-01-25 14:02:55-08 - - $
d18 1
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.16 2016-01-14 16:10:40-08 - - $
d37 3
a39 3
   int exit_status = exit_status::get();
   cout << execname() << ": exit(" << exit_status << ")" << endl;
   return exit_status;
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.15 2016-01-14 15:13:33-08 - - $
d24 1
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.14 2016-01-14 14:45:21-08 - - $
d54 1
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.13 2016-01-13 16:21:53-08 - - $
d35 6
a40 1

d56 1
a72 1

a100 6
}

int exit_status_message() {
   int exit_status = exit_status::get();
   cout << execname() << ": exit(" << exit_status << ")" << endl;
   return exit_status;
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.12 2016-01-13 13:49:20-08 - - $
d6 1
a6 1
commands::commands(): hash ({
d18 1
a18 1
}){}
d20 1
a20 1
command_fn commands::at (const string& cmd) {
d24 2
a25 2
   const auto result = hash.find (cmd);
   if (result == hash.end()) {
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.11 2014-06-11 13:49:31-07 - - $
d26 1
a26 1
      throw yshell_exn (cmd + ": no such function");
d31 4
d54 1
a54 1
   throw ysh_exit_exn();
@


1.11
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.10 2014-04-09 17:04:58-07 - - $
d6 1
a6 1
commands::commands(): map ({
d24 2
a25 2
   command_map::const_iterator result = map.find (cmd);
   if (result == map.end()) {
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.9 2014-03-26 19:55:18-07 - - $
d20 1
a20 1
function commands::at (const string& cmd) {
d23 2
a24 2
   // So: iterator->second is mapped_type (function)
   commandmap::const_iterator result = map.find (cmd);
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.8 2014-03-26 18:39:40-07 - - $
d50 1
a50 1
   throw ysh_exit_exn ();
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.7 2014-03-26 17:15:54-07 - - $
d31 1
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.6 2013-06-18 18:26:51-07 - - $
d4 1
a4 1
#include "trace.h"
d6 13
a18 13
commands::commands(): map (commandmap()) {
   map["cat"    ] = fn_cat    ;
   map["cd"     ] = fn_cd     ;
   map["echo"   ] = fn_echo   ;
   map["exit"   ] = fn_exit   ;
   map["ls"     ] = fn_ls     ;
   map["lsr"    ] = fn_lsr    ;
   map["make"   ] = fn_make   ;
   map["mkdir"  ] = fn_mkdir  ;
   map["prompt" ] = fn_prompt ;
   map["pwd"    ] = fn_pwd    ;
   map["rm"     ] = fn_rm     ;
}
d32 2
a33 2
   TRACE ('c', state);
   TRACE ('c', words);
d37 2
a38 2
   TRACE ('c', state);
   TRACE ('c', words);
d42 2
a43 2
   TRACE ('c', state);
   TRACE ('c', words);
d47 2
a48 2
   TRACE ('c', state);
   TRACE ('c', words);
d53 2
a54 2
   TRACE ('c', state);
   TRACE ('c', words);
d58 2
a59 2
   TRACE ('c', state);
   TRACE ('c', words);
d64 2
a65 2
   TRACE ('c', state);
   TRACE ('c', words);
d69 2
a70 2
   TRACE ('c', state);
   TRACE ('c', words);
d74 2
a75 2
   TRACE ('c', state);
   TRACE ('c', words);
d79 2
a80 2
   TRACE ('c', state);
   TRACE ('c', words);
d84 2
a85 2
   TRACE ('c', state);
   TRACE ('c', words);
d89 2
a90 2
   TRACE ('c', state);
   TRACE ('c', words);
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.5 2013-06-18 18:02:12-07 - - $
d31 1
a31 1
void fn_cat (inode_state &state, const wordvec &words){
d36 1
a36 1
void fn_cd (inode_state &state, const wordvec &words){
d41 1
a41 1
void fn_echo (inode_state &state, const wordvec &words){
d46 1
a46 1
void fn_exit (inode_state &state, const wordvec &words){
d52 1
a52 1
void fn_ls (inode_state &state, const wordvec &words){
d57 1
a57 1
void fn_lsr (inode_state &state, const wordvec &words){
d63 1
a63 1
void fn_make (inode_state &state, const wordvec &words){
d68 1
a68 1
void fn_mkdir (inode_state &state, const wordvec &words){
d73 1
a73 1
void fn_prompt (inode_state &state, const wordvec &words){
d78 1
a78 1
void fn_pwd (inode_state &state, const wordvec &words){
d83 1
a83 1
void fn_rm (inode_state &state, const wordvec &words){
d88 1
a88 1
void fn_rmr (inode_state &state, const wordvec &words){
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.4 2013-06-18 18:00:53-07 - - $
d21 3
@


1.4
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.3 2013-06-18 18:00:24-07 - - $
d25 1
a25 1
   return *result;
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.2 2013-06-18 17:59:10-07 - - $
d23 1
a23 1
      throw yshell_exn (words[0] + ": no such function");
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.1 2013-06-18 17:31:28-07 - - $
d22 1
a22 1
   if (result == map.end) {
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: commands.cpp,v 1.2 2012-03-29 17:31:42-07 - - $
d20 6
a25 2
function commands::operator[] (const string& cmd) {
   return map[cmd];
@
